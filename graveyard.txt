
// RUST BIO TEST
//fn doz(config : &Config){
//    let text = b"ACAGCTATCGGTA";
//    let filename = "data/basic.fasta";
//
//    // instantiate an alphabet
//    let alphabet = alphabets::dna::iupac_alphabet();
//    // calculate a suffix array
//    let pos = suffix_array(text);
//    // calculate BWT
//    let bwt = bwt(text, &pos);
//    // calculate less and Occ
//    let less = less(&bwt, &alphabet);
//    let occ = Occ::new(&bwt, 3, &alphabet);
//    // setup FMIndex
//    let fmindex = FMIndex::new(&bwt, &less, &occ);
//
//    // Iterate over a FASTQ file, use the alphabet to validate read
//    // sequences and search for exact matches in the FM-Index.
//
//    // obtain reader or fail with error (via the unwrap method)
//    let f = File::open(&filename)
//        .expect(&format!("Failed to open input file at {:?}\n", &filename));
//    let reader = fasta::Reader::new(f);
//    for result in reader.records() {
//        // obtain record or fail with error
//        let record = result.unwrap();
//        // obtain sequence
//        let seq = record.seq();
//        if alphabet.is_word(seq) {
//            let interval = fmindex.backward_search(seq.iter());
//            let positions = interval.occ(&pos);
//        }
//    }
//}







//    pub struct Filter{
//        blocks : i32,
//    }
//
//    impl IntoIterator for Filter {
//        type Item = i32;
//        type IntoIter = FilterIterator;
//
//        fn into_iter(self) -> Self::IntoIter {
//            FilterIterator { blocks: self.blocks, next_index: 0 }
//        }
//    }
//
//    pub struct FilterIterator{
//        blocks : i32,
//        next_index : i32,
//    }
//
//    impl Iterator for FilterIterator {
//        type Item = i32;
//        fn next(&mut self) -> Option<i32> {
//            if self.next_index == self.blocks{
//                None
//            } else{
//                self.next_index += 1;
//                Some(if self.next_index == self.blocks {self.next_index-2} else {self.next_index-1})
//            }
//        }
//    }




//    fn iterative_candidates(&self,
//                            cand_set : &mut HashSet<Candidate>,
//                            cns : &SearchConstants,
//                            errors : i32,
//                            p_i : i32,
//                            indel_balance : i32,
//                            a_match_len : i32,
//                            b_match_len : i32,
//                            matches : &Interval,
//                            debug : &str){
//
//
//        let (mut l, mut r) = (0, self.bwt().len() - 1);
//        let mut s = String::new();
//        for &a in cns.pattern.iter().rev() {
//            let less = self.less(a);
//            l = less + if l > 0 { self.occ(l - 1, a) } else { 0 };
//            r = less + self.occ(r, a) - 1;
//            s.push(a as char);
//            println!("   [{},\t{})\t({} element)::\t{}", l, r, r-l, &s);
//        }
//
//        let a = b'$';
//        s.push(a as char);
//        let less = self.less(a);
//        l = less + if l > 0 { self.occ(l - 1, a) } else { 0 };
//        r = less + self.occ(r, a);
//        println!("   [{},\t{})\t({} element)::\t{}", l, r, r-l, &s);
//
//        let x = Interval {
//            lower: l,
//            upper: r,
//        };
//        let positions = x.occ(cns.sa);
//        println!("positions {:?}", &positions);
//        for p in positions {
//            let fetch_index = &(p as i32 + 1);
//            println!("FETCH INDEX {}", fetch_index);
//            let id_b = *cns.maps.bdmap_index_id.get_by_first(fetch_index).expect("DOLLAR MAP BAD");
//            if id_b == cns.id_a{
//                //skip obvious self-matches
//                println!("  !!!!!! SELF CAND {:?}, {:?}", p, debug);
//                continue
//            }
//            let c = Candidate {
//                id_b: id_b,
//                overlap_a: a_match_len,
//                overlap_b: b_match_len,
//                overhang_right_b: 0,
//            };
//            println!("  !!!!!! ~~~  adding FOUND CANDIDATE AT {} with {}", p, debug);
//            cand_set.insert(c);
//            println!("cand set size is now {}", cand_set.len());
//        }
//    }



let max_b_len =
	if config.reversals {patt_len} else {(patt_len as f32 / (1.0 - config.err_rate)).floor() as usize};

pub mod string_walk{
    pub trait Walkable<'a>{
        fn read(&self) -> u8;
        fn can_read(&self) -> bool;
        fn advance(&mut self);
        fn new(&'a [u8]) -> Self;
    }

    #[derive (Clone)]
    pub struct ForwardWalker<'a>{
        src : &'a [u8],
        next_position : usize,
    }

    #[derive (Clone)]
    pub struct BackwardWalker<'a>{
        src : &'a [u8],
        next_position : usize,
    }

    impl<'a> Walkable<'a> for ForwardWalker<'a>{
        fn new(src : &'a [u8]) -> ForwardWalker<'a>{
            ForwardWalker{src:src, next_position:0}
        }

        fn read(&self) -> u8{
            self.src[self.next_position]
        }
        fn can_read(&self) -> bool{
            self.next_position < self.src.len()
        }
        fn advance(&mut self){
            self.next_position += 1;
        }
    }

    impl<'a> Walkable<'a> for BackwardWalker<'a>{
        fn new(src : &'a [u8]) -> BackwardWalker<'a>{
            BackwardWalker{src:src, next_position:src.len()-1}
        }
        fn read(&self) -> u8{
            self.src[self.next_position]
        }
        fn can_read(&self) -> bool{
            self.next_position < self.src.len() && self.next_position > 0
        }
        fn advance(&mut self){
            self.next_position -= 1;
        }
    }
}